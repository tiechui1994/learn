/**
 * IM应用需要解决的三个问题:
 *  1.全双工通信
 *  2.低延迟
 *      即浏览器A发送给B的信息经过服务器要快速转发给B, 同理B的信息也要快速交给A,实际上就是要求任何浏览器能够快速请求服务器的数据,
 *      服务器能够快速推送数据到浏览器;
 *  3.支持跨域
 *      通常客户端浏览器和服务器都是处于网络的不同位置,浏览器本身"不允许通过脚本直接访问不同域名下的服务器",即使IP地址相同域名不同也不行,
 *      域名相同端口不同也不行,这方面主要是为了安全考虑.
 */

/**
 * 解决方案一:
 * 轮询: 客户端定期向服务器发送Ajax请求,服务器接到请求后马上返回响应信息并关闭连接。
 *
 */


/**
 * 解决方案二:
 * 长轮询: 客户端发送一次请求到服务器,服务器查看客户端请求的数据是否发生变化(是否有最新数据), 如果发生变化则立即响应返回; 否则保存这个连接并定期检查
 *        最新数据, 直到发生了数据更新或连接超时. 同时客户端连接一旦断开, 则再发出请求, 这样在相同的时间内大大减少了客户端请求服务器的次数.
 *
 * 不足: 服务器阻塞(保持响应不返回), 客户端轮询
 *
 * 长连接: 在页面里嵌套一个隐藏的iframe, 这个隐藏的iframe的src属性设为一个长连接的请求或是采用xhr请求,服务端就能源源不断的往客户端输入数据.
 *
 * 服务端长连接程序设计注意点:
 *      (1) 服务器程序对轮询的可控性, 由于轮询是死循环的方式实现的,所以在算法上要保证程序何时退出循环的控制能力.
 *      (2) 合理选择"心跳"频率, 长连接必须由客户端不停地进行请求来维持, 所以客户端和服务器间保持正常的"心跳"至为关键, 参数POOLING_LIFE应该小于
 *          WEB服务器的超时时间,一般建议在10-20秒左右.
 *      (3) 网络因素的影响, 在实际应用时,从服务器做出应对,到下一次循环的建立,是有时间延迟的,延迟实际的长短受到网络传输等多种因素影响,在这段时间内,
 *          长连接处于暂时断开的空挡, 如果恰好有数据在这段时间发生变动,服务器是无法立即进行推送的,所以, 在算法设计上要注意解决由于延迟可能造成的数
 *          据丢失的问题.
 **/


/**
 * 解决方案三:
 * 基于http-steam通信: 客户端一次请求中保持和服务器连接不断开,然后服务器源源不断传送数据到客户端
 *  1. 基于XHR对象的streaming
 *     构造一个XHR对象,通过监听onreadystatechange事件, 当它的readyState是3的时候,获取它的responseText然后进行处理, readyState为3表示
 *     数据正在传输中,整个通信还没有结束, 因此它还在不断获取服务器发送过来的数据, 直到readyState为4的时候才表示数据发送完毕,一次通信结束.
 *
 *     两个问题: (1) 一次请求发送的数据量?  (2) 一次请求的超时时间?
 */

/**
 * 解决方案四:
 * SSE(服务器推送事件 Server-sent Events): HTML5提供的新技术. 它能够实现客户端请求服务端,然后服务端利用与客户端建立的这条通信连接push数据给
 *      客户端,客户端接收数据并处理的目的. 从技术层面讲, SSE技术提供的是从服务器单向推送数据给浏览器,但是配合浏览器主动请求,实际上就实现了客户端和
 *      服务端的双向通信.
 *
 * 原理: 在客户端构造一个eventSource对象,该对象具有readySate属性,分别表示如下:
 *          0: 正在连接到服务器
 *          1: 打开连接
 *          2: 关闭连接
 *      同时, eventSource对象会保持与服务器的长连接, 断开后会自动重连, 如果强制关闭连接,可以调用其close方法. 可以监听onmessage事件,服务器遵
 *      循SSE数据传输的格式给客户端,客户端在onmessage事件触发时能够接收到数据,从而进行某种处理.
 *
 * 注意: 服务端发送的数据要遵循一定的格式, 通常发送一条数据的格式是id:(空格)数据(换行符)data:(空格)数据(两个换行符), eg: "id: 1\ndata: xxx\n\n"
 *      如果不遵循这种格式,实际上客户端是会触发error事件的. 这里的id是用来标识每次发送的数据的id,是强制要加的.
 *
 */
