/***********************************************************************************************************************
 * 作用域(scope)
 * 含义: 描述程序中可以访问标识符(变量)的区域. 一个C变量的作用域可以是块作用域, 函数作用域, 函数原型作用域或文件作用域.
 *
 * 块(block)是用一对花括号括起来的代码区域.
 *
 * 函数原型作用域(function prototype scope)用于函数原型中的形参名(变量名). 例如 int mighty(int mouse, double large); 函数原型作用域
 * 的范围是从形参定义到原型声明结束.
 *
 * 变量的定义在函数的外面, 具有文件作用域(file scope). 具有文件作用域的变量, 从它的定义处到该定义所在文件的末尾均可见. 文件作用域变量也称为全
 * 局变量(global varibale)
 *
 **********************************************************************************************************************/


/***********************************************************************************************************************
 * 链接(linkage)
 *
 * C变量有3种链接属性: 外部链接, 内部链接, 无链接.
 * 具有块作用域, 函数作用域或函数原型作用域的变量都是无链接变量. 这意味着这些变量属于定义它们的块.
 * 具有文件作用域的变量可以是外部链接或内部链接. 外部链接变量可以在多个文件程序当中使用, 内部链接变量只能在一个翻译单元中使用.
 *
 **********************************************************************************************************************/


/***********************************************************************************************************************
 * 存储期(storage duration)
 * 含义: 作用域和链接描述了标识符的可见性. 存储期描述了标识符访问的对象的生存期.
 *
 * C对象有4种存储期: static存储期, thread存储期, automatic存储期, allocated存储期
 *
 * static存储期: 存储期是整个程序的执行过程, 只在main函数之前初始化一次存储对象的值. 所有声明为static对象和所有带内部或外部链接且不声明为
 * _Thread_local的对象都拥有此存储期.
 *
 * thread存储期: 存储期是创建的线程的整个执行过程, 在启动线程时初始化存储对象的值.每个线程拥有其自身的私有备份. 所有声明为 _Thread_local
 * 的对象拥有此存储期.
 *
 * automatic存储期: 进入对象声明的block时分配其内存, 而在以任意方式(goto, return, reaching the end)退出时回收分配的内存. 一个例外是
 * 变长数组, 在执行声明时(非block入口)分配其内存, 并在离开变量作用域(非退出)时回收分配的内存. 若递归地进入block,则对每个递归层进行新的分配.
 * 所有函数和非static块作用域对象, 还有块作用域的复合字面量(匿名结构体)拥有此存储期.
 *
 * allocated存储期: 用动态内存分配函数分配和回收的存储.
 **********************************************************************************************************************/


/***********************************************************************************************************************
 *  auto - 自动存储期, 无链接
 *  只对声明在块作用域的对象(除了函数参数列表)有效. 它表示自动存储期与无链接.
 *  注: 自动变量不会初始化, 除非显示初始化它.
 *
 *  register - 自动存储期, 无链接
 *  只对声明在块作用域的对象有效, 包括函数参数列表(!). 它表示自动存储期与无链接. 声明为 register 的对象不能用作取址运算符的参数.
 *  注: 能获取对象的地址
 *
 *
 *  static - 静态存储期 或 线程存储期(与_Thread_local一起使用) 和 内部链接(除非在块作用域)
 *  静态: 该变量在内存中原地不动, 并不是说它的值不变.
 *  仅在对象声明(除了块作用域中[内部无链接]), 函数声明(除了函数参数列表中). 当在类成员(C++)的声明中使用时, 它声明静态成员.
 *  在对象声明中使用时, 它指定静态存储期(除非与 thread_local 一起出现). 在命名空间作用域的声明中使用时, 它指定内部链接.
 *
 *
 *  extern - 静态存储期 或 线程存储期(与_Thread_local一起使用) 和 外部链接(除非已声明带内部链接)
 *  把变量的定义性声明放在在所有函数的外便创建了外部变量. 为了指出该函数使用了外部变量, 可以在函数中使用关键字extern再次声明. 如果一个源代码
 *  文件使用的外部变量定义再另外一个源代码文件中, 则必须用extern在该文件中声明该变量.
 *
 *  仅在变量和函数的声明中允许使用(除了类成员或函数参数列表). 它指定外部链接, 而且技术上不影响存储期, 但不能用于自动存储期的对象的定义, 故所
 *  有extern对象都有静态或线程存储期. 另外, 使用extern且无初始化器的声明不是定义. 如果extern出现在已经带内部链接标识符的声明上, 则标识符
 *  仍然是内部链接. 否则(如果先前的声明是外部的, 无链接的, 或者不在范围内), 则链接是外部的.
 *
 *
 *  _Thread_local - 线程存储期
 *  只对声明于命名空间作用域的对象, 声明于块作用域的对象及静态数据成员允许使用. 它指示对象具有线程存储期. 它能与static或extern结合, 以分别
 *  指定内部或外部链接(但静态成员始终拥有外部链接(C11起)), 但额外的static不影响存储期.
 *
 *
 *  若不提供storage-class specifier, 则默认为:
 *      对所有函数为 extern
 *      对在文件作用域的对象为 extern
 *      对在块作用域的对象为 auto
 *
 *  对于任何用storage-class specifier声明的结构体(struct)或联合体(union), 存储期(但非链接)将递归地应用到其成员上.
 *  在块作用域的函数声明能使用 extern 或不使用storage-class specifier.
 *  在文件作用域的函数声明能使用 extern 或 static.
 *  函数参数不能使用除register之外的任何存storage-class specifier. 注意 static 在数组类型的函数参数中有特殊含义.
 *
 *
 * 存储类别     存储期    作用域    链接    声明方式
 * 自动         自动      块      无链接   块内声明, (可选关键字auto, 但是与C++不兼容)
 * 寄存器       自动      块      无链接   块内,使用关键字register
 * 静态外部链接  静态      文件     外部    所有函数外, 可使用关键字extern
 * 静态内部链接  静态      文件     内部    所有函数外, 使用关键字static
 * 静态无链接    静态      块      无      块内, 使用关键字static
 **********************************************************************************************************************/

#include <zconf.h>
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>

/**
 * static int x;
 * extern int q;
 *
 * inline int y;
 * volatile int z;
 * const int v;
 **/

void static_local_test() {
    static int state = 1;
    printf("the state is:%d \n", state);
    state++;
}

void static_local_param() {
    for (int i = 0; i < 5; i++) {
        static int arg;
        printf("the arg is:%p\n", &arg);
    }
}

void thread_storage_test() {
    static _Thread_local int arg = 100;
    void* job() {
        for (int i = 0; i < 10; i++) {
            pthread_t id = pthread_self();
            printf("pid:%ld,   arg:%d \n", (size_t) id, arg);
            arg = rand();
            printf("new arg:%d \n\n", arg);
            sleep(1);
        }

        return NULL;
    }


    pthread_t tid1, tid2;

    pthread_create(&tid1, NULL, (void*) job, NULL);
    pthread_create(&tid2, NULL, (void*) job, NULL);

    arg = 200;

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
}


void main() {
    static_local_test();
    static_local_test();
    static_local_test();

    static_local_param();
}

